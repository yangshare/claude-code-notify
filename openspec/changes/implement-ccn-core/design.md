# 架构设计文档

## 上下文

**项目目标**：为 Claude Code 打造 Windows 平台下最优雅、可定制的任务通知体验。

**核心约束**：
- 必须是 Windows 原生通知体验（符合 Fluent Design 规范）
- CLI 核心必须无界面、无常驻进程、极速启动
- 不能影响 Claude Code 的正常运行（工具崩溃时）
- 首选保障 Windows 10/11 体验，macOS 为可选

**利益相关者**：
- Claude Code 用户：需要简洁、可靠的通知体验
- Claude Code 团队：需要稳定的 Hook 集成

## 目标 / 非目标

### 目标
- 提供轻量级、响应迅速的通知系统（< 500ms 延迟）
- 实现零配置自动集成体验（`ccn setup` 一键配置）
- 支持高度可定制的通知策略（阈值、声音、图标）
- 提供优雅的交互式配置向导
- 确保系统稳定性和向后兼容性

### 非目标
- 不实现完整的通知历史管理（依赖 Windows 通知中心）
- 不实现跨平台同步配置
- 不实现通知数据分析或统计
- 不实现实时进度显示（仅支持最终状态通知）

## 决策

### 决策 1：编程语言选择

**选择**：**Rust**

**理由**：
- 性能优秀：编译型语言，启动速度快，适合 CLI 工具
- 跨平台支持：通过条件编译支持 Windows 和 macOS
- 生态系统成熟：有优秀的 CLI 框架（clap）和 Windows 通知库
- 内存安全：减少崩溃风险，符合稳定性要求

**考虑的替代方案**：
- **Go**：开发速度快，但二进制文件较大，Windows 通知库支持不如 Rust 成熟
- **Python**：开发最快，但启动速度慢，需要打包整个运行时
- **C#/.NET**：Windows 原生支持最好，但依赖 .NET 运行时，跨平台支持复杂

### 决策 2：Windows 通知库选择

**选择**：**windows-rs** (Microsoft 官方 Rust crate)

**理由**：
- Microsoft 官方维护，API 稳定性有保障
- 直接调用 Windows Runtime API，支持最新的 Toast 通知功能
- 支持交互按钮、进度条、音效等高级特性

**考虑的替代方案**：
- **winrt-rs**：功能类似，但 windows-rs 更现代化
- **toast-rs**：第三方封装，功能有限且更新慢

### 决策 3：配置文件格式

**选择**：**YAML**

**理由**：
- 人类可读性强，适合手写配置
- 支持注释，便于用户理解
- 生态成熟，Rust 有 serde_yaml 支持

**考虑的替代方案**：
- **JSON**：不支持注释，手写体验差
- **TOML**：可读性好，但嵌套结构支持不如 YAML

### 决策 4：配置文件位置

**选择**：**平台标准配置目录**

- Windows: `%APPDATA%\claude-code-notify\config.yaml`
- macOS: `~/Library/Application Support/claude-code-notify/config.yaml`

**理由**：
- 符合平台惯例，用户容易找到
- 避免污染项目目录

### 决策 5：CLI 框架选择

**选择**：**clap** (Command Line Argument Parser)

**理由**：
- Rust 生态中最流行的 CLI 框架
- 支持派生宏，代码简洁
- 自动生成帮助文档
- 支持子命令和复杂参数解析

### 决策 6：TUI 框架选择

**选择**：**ratatui** (原 tui-rs)

**理由**：
- 功能强大，支持复杂交互
- 生态成熟，社区活跃
- 支持跨平台终端

## 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                      Claude Code                             │
│                  (通过 Hooks 调用 ccn)                       │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                   ccn.exe (CLI 核心)                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │  notify  │  │   init   │  │  setup   │  │  config  │   │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
└───────┼─────────────┼─────────────┼─────────────┼──────────┘
        │             │             │             │
        ▼             ▼             ▼             ▼
┌─────────────────────────────────────────────────────────────┐
│                    核心模块层                                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │Notification│  │  Config  │  │  Policy  │  │Integration│  │
│  │ Manager   │  │ Manager  │  │ Engine   │  │ Manager   │  │
│  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘   │
└────────┼──────────────┼──────────────┼──────────────┼──────────┘
         │              │              │              │
         ▼              ▼              ▼              ▼
┌─────────────────────────────────────────────────────────────┐
│                    平台抽象层                                │
│  ┌──────────────────┐         ┌──────────────────┐         │
│  │ Windows Notify   │         │  macOS Notify    │         │
│  │  (windows-rs)    │         │   (mac-rs)       │         │
│  └──────────────────┘         └──────────────────┘         │
└─────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────────────────┐
│              Windows 通知中心 / macOS 通知中心               │
└─────────────────────────────────────────────────────────────┘
```

## 模块职责

### 1. CLI 核心 (ccn.exe)
- 解析命令行参数
- 调度相应子命令
- 管理进程生命周期（极速启动和退出）

### 2. Notification Manager
- 封装平台特定的通知 API
- 管理通知队列和去重
- 处理通知交互回调

### 3. Config Manager
- 读写配置文件
- 验证配置合法性
- 合并默认配置和用户配置

### 4. Policy Engine
- 实现智能阈值过滤
- 实现通知聚合逻辑
- 匹配场景化模板

### 5. Integration Manager
- 侦测 Claude Code 配置文件位置
- 备份和修改配置文件
- 验证集成结果

## 数据流

### 通知发送流程

```
1. Claude Code Hook 触发
   ↓
2. ccn notify 接收参数（status, duration, cmd）
   ↓
3. Policy Engine 检查阈值和策略
   ├─→ 如果被过滤 → 退出
   └─→ 如果通过 → 继续
   ↓
4. Config Manager 加载匹配的模板配置
   ↓
5. Notification Manager 构建通知内容
   ↓
6. 平台抽象层调用系统 API
   ↓
7. 通知显示给用户
   ↓
8. ccn.exe 退出
```

### 配置流程

```
1. 用户运行 ccn init
   ↓
2. TUI 显示配置选项
   ↓
3. 用户交互选择（图标、声音、阈值）
   ↓
4. Config Manager 保存配置
   ↓
5. 显示预览并确认
   ↓
6. ccn.exe 退出
```

### 集成流程

```
1. 用户运行 ccn setup
   ↓
2. Integration Manager 侦测配置文件
   ↓
3. 备份现有配置
   ↓
4. 注入 hooks 配置
   ↓
5. 发送测试通知
   ↓
6. 验证成功/失败
   ↓
7. ccn.exe 退出
```

## 配置文件结构

```yaml
# 全局设置
version: "1.0"
sound_enabled: true
focus_assistant_mode: "respect"  # respect, always, never

# 通知阈值
threshold:
  min_duration: 10  # 秒，低于此值不通知（错误除外）
  whitelist:
    - "deploy"
    - "release"

# 场景化模板
templates:
  default:
    icon: "auto"  # auto, custom_path
    sound: "default"
    duration: 5000  # 毫秒

  build:
    icon: "icons/build.png"
    sound: "sounds/build_success.wav"
    duration: 8000

  test:
    icon: "icons/test.png"
    sound: "sounds/test_complete.wav"
    duration: 5000

# 通知聚合
aggregation:
  enabled: true
  window: 5000  # 毫秒，聚合时间窗口
  max_toasts: 3  # 最多聚合多少条

# 日志设置
logging:
  level: "info"  # debug, info, warn, error
  file: ""  # 空表示仅输出到 stderr
```

## 风险 / 权衡

### 风险 1：Windows 通知 API 兼容性
**风险**：Windows 10 不同版本通知 API 功能差异
**缓解措施**：
- 设置最低版本要求为 Windows 10 版本 1607
- 在启动时检测系统版本，降级不支持的特性
- 提供清晰的错误提示

### 风险 2：Claude Code 配置文件格式变化
**风险**：Claude Code 更新可能改变配置文件格式或 hooks 机制
**缓解措施**：
- 在集成前验证配置文件格式
- 使用保守的注入策略（仅添加，不修改现有内容）
- 提供手动回滚步骤

### 风险 3：通知工具崩溃影响 Claude Code
**风险**：如果 ccn.exe 崩溃，可能导致 Hook 执行失败
**缓解措施**：
- 使用错误边界，确保任何异常都被捕获并静默处理
- 在 Hook 中使用 `|| true` 确保失败不影响后续命令
- 全面的错误处理和日志记录

### 权衡 1：功能丰富性 vs 简洁性
**决策**：优先简洁性，在核心功能稳定后再添加高级特性
**理由**：降低维护成本，减少用户学习曲线

### 权衡 2：跨平台支持 vs Windows 体验优先
**决策**：优先保障 Windows 体验，macOS 仅提供基础通知
**理由**：用户主要使用 Windows，资源有限

## 迁移计划

### 第一阶段（MVP）
- 实现 Windows 基础通知
- 实现基本的 CLI 和配置管理
- 实现手动集成文档

### 第二阶段
- 添加交互式配置向导
- 实现自动集成功能
- 添加智能阈值和聚合

### 第三阶段
- 添加高级交互功能（按钮、点击行为）
- 添加场景化模板
- 优化性能和稳定性

### 回滚策略
- 配置文件修改前自动备份
- 提供卸载命令 `ccn uninstall` 清理 hooks
- 保留详细的操作日志

## 待决问题

1. **通知图标资源**：是否内置默认图标，还是完全依赖用户自定义？
   - 建议：内置一套默认图标，允许用户自定义

2. **音效资源**：是否内置默认音效？
   - 建议：使用系统默认音效，允许用户自定义 WAV 文件

3. **通知历史**：是否需要维护独立的通知历史记录？
   - 建议：否，依赖 Windows 通知中心的历史功能

4. **CLI 名称**：最终的可执行文件名称？
   - 建议：`ccn.exe` (Claude Code Notify)

5. **包分发方式**：如何分发给最终用户？
   - 建议：提供独立二进制下载 + Scoop bucket（Windows）

6. **是否需要 GUI 配置工具**？
   - 建议：否，TUI 足够且更符合开发工具定位
